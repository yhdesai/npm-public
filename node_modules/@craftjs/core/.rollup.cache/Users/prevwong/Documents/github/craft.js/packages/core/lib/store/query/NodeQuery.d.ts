import { LegacyNode, LegacyNodeData, LegacyNodeQuery, NodeEventTypes, NodeId, Node, NodeRules, NodeSelector } from '../../interfaces';
import { EditorStore } from '../EditorStore';
/**
 * NodeQuery helps define a Node in the EditorState
 */
export declare class NodeQuery implements LegacyNodeQuery {
    private readonly store;
    readonly id: NodeId;
    node: Node;
    constructor(store: EditorStore, id: NodeId);
    /**
     * Returns an object with all the properties from both Node and LegacyNode
     * This is primarily used in places such as NodeRules where the Node is exposed to the APIs
     * Hence, we need to consider all existing codebases that're still using the LegacyNode
     * @param node
     * @returns BackwardsCompatibleNode
     */
    private _createBackwardsCompatibleNode;
    private getConfig;
    readonly type: string;
    readonly props: Record<string, any>;
    readonly custom: any;
    getParent(): NodeQuery;
    getAncestors(): NodeQuery[];
    getDescendants(): NodeQuery[];
    getComponent(): any;
    getDOM(): HTMLElement;
    getRules(): NodeRules;
    getRelated(): {};
    getLinkedNodes(): {
        id: string;
        node: NodeQuery;
    }[];
    getChildNodes(): NodeQuery[];
    indexOf(childNodeId: NodeId): number;
    getChildAtIndex(index: any): NodeQuery;
    isCanvas(): boolean;
    isRoot(): boolean;
    isLinkedNode(): boolean;
    isTopLevelNode(): boolean;
    isDeletable(): boolean;
    isParentOfTopLevelNodes(): boolean;
    isParentOfTopLevelCanvas(): boolean;
    isSelected(): boolean;
    isHovered(): boolean;
    isDragged(): boolean;
    isDraggable(onError?: (err: string) => void): boolean;
    isDroppable(selector: NodeSelector, onError?: (err: string) => void): boolean;
    toNodeTree(): {
        rootNodeId: string;
        nodes: {};
    };
    private find;
    /**
     * @deprecated
     */
    readonly data: LegacyNodeData;
    /**
     * @deprecated
     */
    readonly events: Record<NodeEventTypes, boolean>;
    /**
     * @deprecated
     */
    readonly dom: HTMLElement;
    /**
     * @deprecated
     */
    readonly related: {};
    /**
     * @deprecated
     */
    readonly rules: NodeRules;
    /**
     * @deprecated
     */
    readonly _hydrationTimestamp: number;
    /**
     * @deprecated
     * @returns
     */
    linkedNodes(): string[];
    /**
     * @deprecated
     * @returns
     */
    childNodes(): string[];
    /**
     * @deprecated
     * @returns
     */
    isTopLevelCanvas(): boolean;
    /**
     * @deprecated
     * @param deep
     * @returns
     */
    ancestors(deep?: boolean): NodeId[];
    /**
     * @deprecated
     * @param deep
     * @param includeOnly
     * @returns
     */
    descendants(deep?: boolean, includeOnly?: 'linkedNodes' | 'childNodes'): NodeId[];
    /**
     * @deprecated
     */
    get(): LegacyNode;
    /**
     * @deprecated
     */
    toSerializedNode(): import("../../interfaces").SerializedNode;
}
