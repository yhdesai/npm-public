import { ERROR_TOP_LEVEL_ELEMENT_NO_ID, useEffectOnce } from '@craftjs/utils';
import React, { useState } from 'react';
import invariant from 'tiny-invariant';
import { NodeElement } from './NodeElement';
import { useInternalNode } from './useInternalNode';
import { useInternalEditor } from '../editor/useInternalEditor';
import { ERROR_NOT_IN_RESOLVER } from '@craftjs/utils';
import { mergeTrees } from '../utils/mergeTrees';
import { resolveComponent } from '../utils/resolveComponent';
import { createNodeWithResolverConfig } from '../utils/types';
export const defaultElementProps = {
    is: 'div',
    canvas: false,
    custom: {},
    hidden: false,
};
export const elementPropToNodeData = {
    is: 'type',
    canvas: 'isCanvas',
};
export function Element({ id, children, ...elementProps }) {
    const { is } = {
        ...defaultElementProps,
        ...elementProps,
    };
    const { query, actions } = useInternalEditor();
    const { id: nodeId, linkedNodes, inNodeContext } = useInternalNode((node) => ({
        linkedNodes: node.linkedNodes(),
    }));
    const [linkedNodeId, setLinkedNodeId] = useState(null);
    useEffectOnce(() => {
        invariant(!!id, ERROR_TOP_LEVEL_ELEMENT_NO_ID);
        if (inNodeContext) {
            let linkedNodeId;
            const existingNode = linkedNodes && linkedNodes[id] && query.node(linkedNodes[id]).get();
            // Render existing linked Node if it already exists (and is the same type as the JSX)
            if (existingNode && existingNode.data.type === is) {
                linkedNodeId = existingNode.id;
            }
            else {
                // otherwise, create and render a new linked Node
                const linkedElement = React.createElement(Element, elementProps, children);
                const tree = query.parseReactElement(linkedElement).toNodeTree();
                linkedNodeId = tree.rootNodeId;
                actions.history.ignore().addLinkedNodeFromTree(tree, nodeId, id);
            }
            setLinkedNodeId(linkedNodeId);
        }
    });
    return linkedNodeId ? React.createElement(NodeElement, { id: linkedNodeId }) : null;
}
export function parseNodeFromJSX(element, resolver, normalize) {
    let { type: componentType, props: componentProps } = element;
    const nodeConfig = {
        type: 'div',
        displayName: 'div',
        props: {},
        isCanvas: false,
        hidden: false,
        custom: {},
    };
    if (componentType === Element) {
        const { is, canvas, custom, hidden, ...props } = {
            ...defaultElementProps,
            ...componentProps,
        };
        componentType = is;
        nodeConfig.isCanvas = canvas;
        nodeConfig.custom = custom;
        nodeConfig.hidden = hidden;
        nodeConfig.props = {
            ...nodeConfig.props,
            ...props,
        };
    }
    else {
        nodeConfig.props = componentProps;
    }
    nodeConfig.type = resolveComponent(resolver, componentType);
    nodeConfig.displayName = nodeConfig.type;
    invariant(nodeConfig.type, ERROR_NOT_IN_RESOLVER);
    const node = createNodeWithResolverConfig(nodeConfig, resolver);
    if (normalize) {
        normalize(node, element);
    }
    let childrenNodes = [];
    if (node.props.children) {
        childrenNodes = React.Children.toArray(node.props.children).reduce((accum, child) => {
            if (React.isValidElement(child)) {
                accum.push(parseNodeFromJSX(child, resolver));
            }
            return accum;
        }, []);
        if (childrenNodes.length > 0) {
            delete node.props.children;
        }
    }
    return mergeTrees(node, childrenNodes);
}
//# sourceMappingURL=Element.js.map