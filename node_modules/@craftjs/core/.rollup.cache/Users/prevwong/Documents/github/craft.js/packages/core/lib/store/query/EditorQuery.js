import { deprecationWarning, ERROR_NOT_IN_RESOLVER, getDOMInfo, ROOT_NODE, } from '@craftjs/utils';
import invariant from 'tiny-invariant';
import { NodeQuery } from './NodeQuery';
import findPosition from '../../events/findPosition';
import { deserializeNode } from '@/utils/deserializeNode';
import { getNodesFromSelector } from '@/utils/getNodesFromSelector';
import { parseNodeFromJSX } from '../../nodes/Element';
import { adaptLegacyNode } from '../../utils/types';
import { EventHelpers } from '../EventHelpers';
export class EditorQuery {
    constructor(store) {
        this.store = store;
        this.store = store;
    }
    get state() {
        return this.store.getState();
    }
    get root() {
        return this.node(ROOT_NODE);
    }
    isEnabled() {
        return this.state.enabled;
    }
    node(id) {
        const node = this.state.nodes[id];
        if (!node) {
            return null;
        }
        return new NodeQuery(this.store, id);
    }
    event(eventType) {
        return EventHelpers(this.state, eventType);
    }
    getDropPlaceholder(source, target, pos, nodeIdToDOM) {
        const state = this.state;
        const targetNode = state.nodes[target], isTargetCanvas = this.node(target).isCanvas();
        const targetParent = isTargetCanvas
            ? targetNode
            : state.nodes[targetNode.parent];
        if (!targetParent)
            return;
        const targetParentNodes = targetParent.nodes || [];
        const dimensionsInContainer = targetParentNodes
            ? targetParentNodes.reduce((result, id) => {
                const dom = nodeIdToDOM ? nodeIdToDOM(id) : this.node(id).getDOM();
                if (dom) {
                    const info = {
                        id,
                        ...getDOMInfo(dom),
                    };
                    result.push(info);
                }
                return result;
            }, [])
            : [];
        const dropAction = findPosition(targetParent.id, dimensionsInContainer, pos.x, pos.y);
        const currentNode = targetParentNodes.length &&
            state.nodes[targetParentNodes[dropAction.index]];
        const output = {
            placement: {
                ...dropAction,
                currentNode: currentNode.id,
            },
            error: false,
        };
        const sourceNodes = getNodesFromSelector(this.store, source);
        sourceNodes.forEach(({ node, exists }) => {
            if (!exists) {
                return;
            }
            // If source Node is already in the editor, check if it's draggable
            this.node(node.id).isDraggable((err) => (output.error = err));
        });
        // Check if source Node is droppable in target
        this.node(targetParent.id).isDroppable(source, (err) => (output.error = err));
        return output;
    }
    getState() {
        return this.state;
    }
    /**
     * @deprecated
     * @param reactElement
     * @returns
     */
    parseReactElement(reactElement) {
        return {
            toNodeTree: (normalize) => {
                return parseNodeFromJSX(reactElement, this.store.resolver, normalize);
            },
        };
    }
    get history() {
        return {
            canUndo: () => this.store.history.canUndo(),
            canRedo: () => this.store.history.canRedo(),
        };
    }
    /**
     * @deprecated
     */
    get events() {
        return this.state.events;
    }
    /**
     * @deprecated
     */
    get nodes() {
        return Object.keys(this.state.nodes).reduce((accum, nodeId) => ({
            ...accum,
            [nodeId]: new NodeQuery(this.store, nodeId),
        }), {});
    }
    /**
     * @deprecated
     */
    get options() {
        return {
            ...this.store.config,
            enabled: this.isEnabled(),
        };
    }
    /**
     * @deprecated
     */
    get indicator() {
        return this.state.indicator;
    }
    /**
     * @deprecated
     */
    get timestamp() {
        return this.state.timestamp;
    }
    /**
     * @deprecated
     */
    getEvent(eventType) {
        return this.event(eventType);
    }
    /**
     * @deprecated
     */
    getOptions() {
        return this.options;
    }
    /**
     * @deprecated
     */
    getSerializedNodes() {
        return Object.keys(this.state.nodes).reduce((accum, id) => ({
            ...accum,
            [id]: this.node(id).toSerializedNode(),
        }), {});
    }
    /**
     * @deprecated
     */
    serialize() {
        return JSON.stringify(this.getSerializedNodes());
    }
    /**
     * @deprecated
     * @param serializedNode
     */
    parseSerializedNode(serializedNode) {
        return {
            toNode: (normalize) => {
                const data = deserializeNode(serializedNode, this.store.resolver);
                invariant(data.type, ERROR_NOT_IN_RESOLVER);
                const id = typeof normalize === 'string' && normalize;
                if (id) {
                    deprecationWarning(`query.parseSerializedNode(...).toNode(id)`, {
                        suggest: `query.parseSerializedNode(...).toNode(node => node.id = id)`,
                    });
                }
                return this.parseFreshNode({
                    ...(id ? { id } : {}),
                    data,
                }).toNode(!id && normalize);
            },
        };
    }
    /**
     * @deprecated
     * @param freshNode
     */
    parseFreshNode(freshNode) {
        return {
            toNode: (normalize) => {
                let node = adaptLegacyNode(freshNode, this.store.resolver);
                const { type, name, ...data } = freshNode.data;
                node = {
                    ...node,
                    ...data,
                };
                if (normalize) {
                    normalize(node);
                }
                return node;
            },
        };
    }
}
//# sourceMappingURL=EditorQuery.js.map