{"version":3,"file":"EventHandlers.js","sourceRoot":"","sources":["../../src/EventHandlers/EventHandlers.ts"],"names":[],"mappings":"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","sourcesContent":["import { ConnectorRegistry } from './ConnectorRegistry';\nimport {\n  EventHandlerUpdates,\n  CraftEventListener,\n  EventHandlerConnectors,\n  CraftDOMEvent,\n  Connector,\n} from './interfaces';\nimport { isEventBlockedByDescendant } from './isEventBlockedByDescendant';\n\nexport abstract class EventHandlers<O extends Record<string, any> = {}> {\n  options: O;\n\n  private registry: ConnectorRegistry = new ConnectorRegistry();\n  private subscribers: Set<(msg: EventHandlerUpdates) => void> = new Set();\n\n  constructor(options?: O) {\n    this.options = options;\n  }\n\n  listen(cb: (msg: EventHandlerUpdates) => void) {\n    this.subscribers.add(cb);\n    return () => this.subscribers.delete(cb);\n  }\n\n  disable() {\n    this.registry.disable();\n\n    this.subscribers.forEach((listener) => {\n      listener(EventHandlerUpdates.HandlerDisabled);\n    });\n  }\n\n  enable() {\n    this.registry.enable();\n\n    this.subscribers.forEach((listener) => {\n      listener(EventHandlerUpdates.HandlerEnabled);\n    });\n  }\n\n  cleanup() {\n    this.disable();\n    this.subscribers.clear();\n    this.registry.clear();\n  }\n\n  addCraftEventListener<K extends keyof HTMLElementEventMap>(\n    el: HTMLElement,\n    eventName: K,\n    listener: CraftEventListener<K>,\n    options?: boolean | AddEventListenerOptions\n  ) {\n    const bindedListener = (e: CraftDOMEvent<HTMLElementEventMap[K]>) => {\n      if (!isEventBlockedByDescendant(e, eventName, el)) {\n        e.craft.stopPropagation = () => {\n          if (!e.craft.blockedEvents[eventName]) {\n            e.craft.blockedEvents[eventName] = [];\n          }\n\n          e.craft.blockedEvents[eventName].push(el);\n        };\n\n        listener(e);\n      }\n    };\n\n    el.addEventListener(eventName, bindedListener, options);\n\n    return () => el.removeEventListener(eventName, bindedListener, options);\n  }\n\n  // Defines the connectors and their logic\n  abstract handlers(): Record<string, (el: HTMLElement, ...args: any[]) => any>;\n\n  get connectors(): EventHandlerConnectors<this> {\n    const connectors = this.handlers();\n    return Object.keys(connectors).reduce<Record<string, Connector>>(\n      (accum, connectorName) => ({\n        ...accum,\n        [connectorName]: (el, required, options) => {\n          this.registry.register(el, {\n            required,\n            name: connectorName,\n            options,\n            connector: connectors[connectorName],\n          });\n          return el;\n        },\n      }),\n      {}\n    ) as any;\n  }\n\n  derive<C extends EventHandlers>(\n    type: {\n      new (...args: any[]): C;\n    },\n    opts: C['options']\n  ) {\n    return new type(this, opts);\n  }\n\n  // This method allows us to execute multiple connectors and returns a single cleanup method for all of them\n  protected createProxyHandlers<H extends EventHandlers>(\n    instance: H,\n    cb: (connectors: EventHandlerConnectors<H>) => void\n  ) {\n    const connectorsToCleanup = [];\n    const handlers = instance.handlers();\n\n    const proxiedHandlers = new Proxy(handlers, {\n      get: (target, key: any, receiver) => {\n        if (key in handlers === false) {\n          return Reflect.get(target, key, receiver);\n        }\n\n        return (el, ...args) => {\n          const cleanup = handlers[key](el, ...args);\n          if (!cleanup) {\n            return;\n          }\n\n          connectorsToCleanup.push(cleanup);\n        };\n      },\n    });\n\n    cb(proxiedHandlers as any);\n\n    return () => {\n      connectorsToCleanup.forEach((cleanup) => {\n        cleanup();\n      });\n    };\n  }\n\n  // This lets us to execute and cleanup sibling connectors\n  reflect(cb: (connectors: EventHandlerConnectors<this>) => void) {\n    return this.createProxyHandlers(this, cb);\n  }\n}\n"]}